### 进程和线程的概念，以及为什么要有进程线程，其中有什么区别，它们各自又是怎么同步的

P73 P88 P89 P103

**进程：** 进程是对运行时程序的封装，是系统进行资源**调度和分配**的基本单位，实现了**操作系统的并发**。

**线程：** 是进程的子任务，是**CPU调度和分派**的基本单位，用于保证程序的实时性，实现**进程内部的并发**。线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一**地址空间**（也就是同样的动态内存，映射文件，目标代码等），打开的**文件队列**和其他内核资源。

**区别：**

1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖进程而存在。

2、进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量或静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量）

3、进程是资源分配的最小单位，线程是CPU调度的最小单位

4、系统开销：由于在创建或撤销进程时，系统都要为之分配或者回收资源，如内存空间、IO设备等。因此，操作系统所付出的开销将显著地大于在创建或撤销线程时的开销。类似的，在进行进程切换时，涉及到整个当前进程CPU环境保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量的寄存器内容，并不涉及存储器管理方面的操作。可见，进程切换的开销要远大于线程切换的开销。

5、通信：由于同一进程中多个线程具有相同的地址空间，致使他们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预。

6、进程编程调试简单可靠性高，但是创建销毁开销大；线程相反，开销小，切换速度快，但是编程调试相对复杂。

7、进程间不会相互影响；线程间一个线程挂掉会将导致整个进程挂掉

8、进程适合多核、多机分布；线程适合于多核





#### **进程间通信的方式**

进程间通信主要包括**管道**、**系统IPC**（包括**消息队列、信号量、信号、共享内存**等）、以及**套接字socket**

**1、管道**

管道主要包括**无名管道和命名管道**：

无名管道管道可用于具有亲缘关系的父子进程间的通信；

有名管道除了具有无名管道所具有的功能外，它还允许无亲缘关系进程间的通信。

**1.1普通管道PIPE：**

（1）它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端

（2）它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）

（3）它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

**1.2 命名管道FIFO**

（1）FIFO可以在无关的进程之间交换数据

（2）FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。



**2、系统IPC**

**2.1 消息队列**

消息队列，是消息的链表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。（消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点）具有写权限的进程可以按照一定的规则向消息队列中添加新信息；对有读权限的进程则可以从消息队列中读取信息。

**特点：**

（1）消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级 （面向记录）

（2）消息队列独立于发送和接收进程。进程终止时，消息队列及其内容不会被删除。（持久化）

（3）消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。（随机读取）



**2.2 信号量**

信号量于已经介绍过的IPC结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

**特点：**

（1）信号量用于进程间同步，若要在进程间传递数据需要结合共享内存

（2）信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作

（3）每次对信号量的PV操作不仅限于对信号量值+1或-1，而且可以加减任意正整数

（4）支持信号量组

**2.3 信号**

信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生

**2.4 共享内存**

它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。

**特点：**

（1）共享内存是最快的一种IPC，因为进程是直接对内存进行存取

（2）因为多个进程可以同时操作，所以需要进行同步

（3）信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问

**3、套接字**

socket编程也是一种进程间通信机制，与其他通信机制不同的是，它可以用于不同主机之间的进程通信。



#### 线程间的通信方式

**临界区：** 通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；

**互斥量：** 采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问

**信号量：** 为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数

**事件（信号）：** 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作



### 有了进程为什么还要有线程

P85

**线程产生的原因：** 进程可以使多个程序能并发执行，以提高资源的利用率和系统吞吐量；

但是其具有一些**缺点**：

进程在同一时间**只能干一件事**

进程在执行的过程中如果**阻塞**，整个进程就会挂起，即使进程中有些工作**不依赖等待的资源**仍然**不会执行**

因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。和进程比起来，线程的优势如下：

从**资源**上来讲，线程是一种非常“节俭”的多任务操作方式。在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段、和数据段，这是一种“昂贵”的多任务工作方式。

从**切换效率**上来讲，运行一个进程中的多个线程，它们之间使用相同的地址空间，而线程间彼此切换所需时间也远远小于进程间切换所需的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。

从**通信机制**上来讲，线程间方便的通信机制。对于不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。

除以上优点外，多线程程序作为一个多任务、并发的工作方式，还有如下优点：

1、使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行在不同的CPU上

2、改善程序结构。一个既长又复杂的进程可以考虑分为多个进程，成为几个独立或半独立的运行部分，这样的程序才会有利于理解和修改



### 多线程和多进程的不同

P88

进程是资源分配的最小单位，而线程是CPU调度的最小单位。

多线程之间共享同一个进程的地址空间。线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存也少，适用于多核分布式系统，但是线程间会相互影响，一个线程意外终止会导致同一进程的其他线程也终止，程序可靠性弱。

而多进程之间拥有独立的运行地址空间，进程间不会相互影响，程序可靠性高，但是创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单嘛，适用于多核、多机分布

### 多进程和多线程的使用场景

P89

多进程模型，适用于CPU密集型。同时，多进程模型也适用于多机分布式场景中，易于多机扩展。

多线程模型主要优势为线程间切换代价小，因此适用于I/O密集型的工作场景，因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁切换线程。

### 游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么

游戏服务器应该为每一个用户开辟一个进程。因为同一进程的的线程会相互影响，一个线程死掉就会影响其他线程，从而导致进程崩溃，因此为了保证不同用户之间不会相互影响，应该为每个用户开辟一个进程。

### 请问线程需要保存那些上下文，SP、PC、EAX这些寄存器是干嘛用的

P86

线程在切换的过程中需要保存当前**线程id，线程状态，堆栈，寄存器**状态等信息。其中寄存器主要包括SP、PC、EAX等寄存器，其主要功能如下：

SP：堆栈指针，指向当前栈的栈顶地址

PC：程序计数器，存储下一条即将执行的指令

EAX：累加寄存器，用于加法惩罚的缺省寄存器

### 单核机器上写多线程程序，是否需要考虑加锁，为什么

P86

在单核机器上写多线程程序，仍然需要线程锁。因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能导致共享数据修改引起冲突。

### 系统调用是什么，用过哪些系统调用

P119

在计算机中，系统调用又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供了用户程序与操作系统之间的接口（即系统调用是用户程序和内核交互的接口）

操作系统中的状态分为管态（核心态）和目态（用户态）。大多数系统交互操作需求在内核态执行。如设备IO操作或者进程间通信。

特权指令：一类只能在核心态下运行而不能在用户态运行的特殊指令。不同的操作系统特权指令会有所差异，但是一般来说主要是和硬件相关的一些指令。用户程序只在用户态下运行，有时需要**访问系统核心功能**，这时通过系统调用接口使用系统调用。

应用程序有时会需要一些危险的、权限很高的指令，如果把这些权限放心的交给用户程序是很危险的（比如一个进程可能修改另一个进程的内存区，导致其不能运行），但是又不能完全不给这些权限。于是就有了系统调用，危险的指令被包装成系统调用，用户程序只能调用而无权自己运行这些指令。另外，计算机硬件的资源是有限的，为了更好的管理这些资源，所有资源都由操作系统控制，进程稚嫩恶搞向操作系统请求这些资源。操作系统是这些资源的唯一入口，这个入口就是系统调用。

写数据write，创建进程 fork，vfork等都是系统调用

### 线程间的同步方式，最好说出具体的系统调用

P87

**信号量：** 

信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：

P(SV):如果信号量SV大于0，将它减1；如果SV值为0，则挂起该线程

V(SV):如果有其他进程因为等待SV而挂起，则唤醒。然后将SV+1；否则直接将SV+1.其系统调用为：

sem_wait(sem_t*sem)：以原子操作的方式将信号量-1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量有非0值。

sem_post(sem_t*sem)：以原子操作将信号量值+1.当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒

**互斥量：**

互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待互斥锁的线程。其主要的系统调用如下：

pthread_mutex_init: 初始化互斥锁

pthread_mutex_destroy:销毁互斥锁

pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock将阻塞，直到该互斥锁的占有者将其解锁。

pthread_mutex_unlock：以一个原子操作的方式给一个互斥锁解锁

**条件变量：**

条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程通信机制：当某个共享数据达到某个值的时候，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值的时候，调用signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如

pthread_cond_init：初始化条件变量

pthread_cond_destroy：销毁条件变量

pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级

pthread_cond_wait：等待目标条件变量，需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。



### 说一说多线程同步，锁的机制

P112 P128

同步的时候用一个互斥量，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量加锁以后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁。如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥量加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。在这种状态下，每次只有一个线程可以向前执行。

### 怎么确定当前线程是繁忙还是阻塞

P111



### 就绪状态的进程在等待什么

P111

### 多线程和多进程的通信方式

P113

### 线程模型

P116

### 怎么实现线程池

P129

### 说一说协程

P118

### Linux虚拟地址空间

P76

### 操作系统中程序的内存结构

P77

### 操作系统中的缺页中断

P78

### 操作系统中的页表寻址

P83

### OS缺页置换算法

P89

### 虚拟内存和物理内存如何对应

P91

### 虚拟内存置换方式

P99

### 内存溢出和内存泄漏

P115

### 介绍一下操作系统的中断

P139

中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的程序，保存现场后自动去执行相应的处理程序，处理完该事件后再次返回中断处继续执行原来的程序。中断一般分为3类，一种是由CPU外部引起的，如I/O中断、时钟中断，一种是来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，地址越界，浮点溢出，最后一种是在程序使用了系统调用引起的。而中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中断处理由软件实施

### 死锁发生的条件以及如何解决死锁

P90 P113

### 讲述一下互斥锁机制，以及互斥锁和读写锁的区别

P102

### 两个进程访问临界区，会不会出现都获得自旋锁的情况

P112

### C++的锁有几种

P112

### 说一说你用到的锁

P112

### fork和vfork的区别

P79

### 写一下fork调用示例

P121

### 如何修改文件最大句柄数

P81

### 并发和并行

P82

### MySQL的端口号是多少，如何修改这个端口号

P83

### 操作系统中的结构体对齐，字节对齐

P96

### 说一说状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞

P104

### A * a = new A; a->i = 10; 在内核中的内存分配发生了什么

P106

### 给你一个类，里面有static，vortual之类的，来说一说这个类的内存分布

P107

### 软链接与硬链接的区别

P109

### 什么大端小端以及如何判断大端小端

P110

### 静态变量什么时候初始化

P110

### 操作系统为什么要分内核态和用户态

P127

### 用户态和管态的区别

P110

### 用户态到内核态的转化原理

P122

### 如何设计server，使得能够接收多个客户端的请求

P111

### 死循环+来连接时新建的方法效率有点低，怎么改进

P111

### 怎么唤醒被阻塞的socket线程

P111

### windows消息机制

P112

### 微内核和宏内核

P125

### 僵尸进程

P125

### GDB调试用过吗，什么是条件断点

P126

### 介绍五种IO模型

P127

### 说一说异步编程的事件循环

P127

### 为什么要有pagecache，操作系统怎么设计的pagecache

P128

### server端监听端口，但还没有客户端连进来，此时处于什么状态

P128

###Linux下怎么得到一个文件的100行到200行

P129

### 说一下awk的使用

P129

###说一下Linux内核中的Timer定时器机制

P131
