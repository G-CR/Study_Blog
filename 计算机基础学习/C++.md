## 基本语言

### 1、引用和指针的区别

1、指针有自己的一块空间，而引用只是一个别名 （空间）

2、使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小 （大小）

3、指针可以被初始化为NULL，而引用必须被初始化为一个已有的对象的大小 （NULL）

4、作为参数传递时，指针需要被引用才可以对对象进行操作，而对引用的修改都会改变引用所指向的对象 （传参）

5、可以有const指针，但是没有const引用 （const)

6、指针在使用中可以只想其他对象，但是引用只能是一个对象的引用，不能被改变 （改变对象）

7、指针可以有多级指针(**p)，而引用只有一级 （多级）

8、指针和引用使用++运算的意义不一样 （++）

9、如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏 （内存泄漏）



### 2、C++与C的区别

设计思想上：C++是面向对象的语言，而C是面向结构化编程的语言

语法上：

C++具有重载、继承和多态三种特性

C++相比C，增加了许多类型安全的功能，比如强制类型转换

C++支持范式编程，比如模版类、函数模板等



### 3、static的作用

**1、全局静态变量**

在全局变量前加关键字static，全局变量就定义成一个全局静态变量。

静态存储区，在整个程序运行期间一直存在

初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非它被显式的初始化）

作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

**2、局部静态变量**

在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。

内存中的位置：静态存储区

初始化：未经初始化的全局静态变量会被初始化为0

作用域：作用域认为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束，但是当局部静态变量离开作用域后，并没有销毁。而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。

**3、静态函数**

在函数返回类型前static，函数被定义为静态函数，函数的定义和声明在默认情况下都是extern的，但是静态函数只是在声明他的文件当中可见，不能被其他文件所用。

函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突。

warnig：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰

**4、静态类**

在类中，静态函数可以实现多个对象之间的共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中的共享成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有成员共用。

**5、类的静态函数**

静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名



### 4、C++中四种cast转换

https://www.bilibili.com/video/BV1ZN411Q7w5

C++中四种类型转换是：static_cast，dynamic_cast，const_cast，reinterpret_cast

1、const_cast ：用于将const变量转为非const

2、static_cast：用于各种隐式转换，比如非const转const，void*转指针等，static_cast 能用于多态向上转化，如果向下转能成功但是不安全，结果未知

3、dynamic_cast：用于动态类型转换。只能用于含有虚函数的类，用于层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。

向上转换：指的是自类向基类的转换

向下转换：指的是基类向子类的转换

它通过判断在执行到该语句的时候变量运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。

4、reinterpret_cast

几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用

5、为什么不用C的强制转换

C的强制转换表面上看起来功能强大，但是转化不够明确，不能进行错误检查，容易出错。

### 5、介绍一下C++的智能指针

智能指针主要用于管理堆上分配的内存，它将普通的指针封装成一个栈对象。当栈对象的生命周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。

C++11中最常用的智能指针类型为shared_ptr，它采用引用计数的的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数+1，当过期时引用计数-1.只有引用计数为0时，智能指针才会自动释放掉引用的内存资源。

对shared_ptr进行初始化时不能将普通指针直接赋给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针，并可以通过get函数获得普通指针。

### 6、请你说一下你理解的C++中的四个智能指针：

shared_ptr，unique_ptr，weak_ptr，auto_ptr p18

使用智能指针的原因：智能指针的作用是管理一个指针，因为存在以下情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。



1、auto_ptr

```cpp
auto_ptr<string> p1 (new string ("hello"));
auto_ptr<string> p2;
p2 = p1; //此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错，所以auto_ptr的缺点就是：存在潜在的内存崩溃问题
cout << *p1; // 导致段错误
```



2、unique_ptr

```cpp
unique_ptr实现独占式拥有或严格拥有的概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄漏（例如“以new创建对象后因为发生异常而忘记调用delete“）特别有用
  
采用所有权模式，还是上面的例子
unique_ptr<string> p1 (new string("hello"));
unique_ptr<string> p2;
p2 = p1; // 此时会报错
// 编译器认为 p2 = p1 非法，避免了p1不再指向有效数据的问题。因此，unique_ptr比 auto_ptr 更安全

另外unique_ptr还有更聪明的地方：当程序试图将一个unique_ptr赋值给另一个时，如果资源unique_ptr是个临时右值，编译器允许这么做；如果源unique_ptr将存在一段时间，编译器将禁止这么做，比如：
unique_ptr<string> pu1(new string("hello"));
unique_ptr<string> pu2;
pu2 = pu1;  // #1 不允许
unique_ptr<string> pu3;
pu3 = unique_ptr<string> (new string("you")); // #2 允许

其中#1留下悬挂的pu1，这可能导致危害，而#2不会留下悬挂的unique_ptr，因为它调用的事unique_ptr的构造函数，该构造函数创建的临时对象在其所有权让给pu3之后就会被销毁。这种随情况而已的行为表明，unique_ptr优于允许两种赋值的auto_ptr
  
如果非要执行类似于#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：
unique_ptr<string> ps1, ps2;
ps1 = unique_ptr<string>(new string("hello"));
ps2 = move(ps1);
ps1 = unique_ptr< string>(new string("ok"));
cout << *ps1 << " " << *ps2 << endl;
```



3、shared_ptr

```cpp
shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”的时候释放。从名字share就可以看出资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr,unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数-1.当计数等于0时，资源会被释放。

shared_ptr 是为了解决auto_ptr在对象所有权上的局限性（auto_ptr是独占的），在使用引用计数的机制上提供了可以共享所有权的智能指针
成员函数：
  use_count() 返回引用计数的个数
  unique() 返回是否独占所有权
  swap() 交换两个shared_ptr对象（即交换所拥有的对象）
  reset() 放弃内部对象的所有权或者拥有对象的变更，会引起原油对象的引用计数的减少
  get() 返回内部对象(指针)，由于已经重载了get方法，因此和直接使用对象是一样的;
		如 shared_ptr <int> sp (new int(1)); sp 与 sp.get() 等价的
```



4、weak_ptr

```cpp
weak_ptr是一种不控制对象生命周期的智能指针，它指向一个shared_ptr管理的对象。进行该对象的内存管理的是那个强引用的shared_ptr. weak_ptr只是提供了对象管理的一个访问手段。weak_ptr设计目的是为了配合shared_ptr而引入的一种智能指针以协助shared_ptr工作，它只可以从一个shared_ptr或另一个weak_ptr对象构造，它的构造和析构不会引起引用计数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时引起的思索问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给他，它可以通过调用lock函数来获得shared_ptr

#include <bits/stdc++.h>
using namespace std;

class B;
class A {
public:
	shared_ptr<B> pb_;
  // weak_ptr<B> pb_; 就没有问题了
};

class B {
public:
	shared_ptr<A> pa_;
};

void fun() {
	shared_ptr<B> pb(new B());
	shared_ptr<A> pa(new A());
	pb->pa_ = pa;
	pa->pb_ = pb;
	cout << pb.use_count() << endl;
	cout << pa.use_count() << endl;
}

int main() {
	fun();
	return 0;
}

可以看到fun函数中pa，pb相互引用，两个资源的引用计数为2，当跳出函数时，智能指针pa，pb析构时两个资源引用计数会-1，但是两者引用计数还是1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_ 改为 weak_ptr pb_；这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数-1，同时pa析构时使A的计数-1，那么A的计数为0，A得到释放。

注意的是我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print（），我们不能这样访问 pa->pb_->print() ；因为p b_是一个weak_ptr ，应该先把它转化为 shared_ptr ，如：shared_ptr p = pa->pb.lock(); p->print();
```



### 7、请你回答一下智能指针有没有内存泄漏的情况

当两个对象相互使用shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。

```cpp
#include <bits/stdc++.h>
using namespace std;

class Child;
class Parent {
private:
	shared_ptr<Child> ChildPtr;
public:
	void setChild(shared_ptr<Child> child) {
		this->ChildPtr = child;
	}
	void doSomething() {
		if(this->ChildPtr.use_count()) {
			
		}
	}
	
	~Parent() {
		
	}
};

class Child {
private:
	shared_ptr<Parent> ParentPtr;
public:
	void setParent(shared_ptr<Parent> parent) {
		this->ParentPtr = parent;
	}
	void doSomething() {
		if(this->ParentPtr.use_count()) {
			
		}
	}
	~Child() {
		
	}
};


int main() {
	weak_ptr<Parent> wpp;
	weak_ptr<Child> wpc;
	{
		shared_ptr<Parent> p(new Parent);
		shared_ptr<Child> c(new Child);
		p->setChild(c);
		c->setParent(p);
		wpp = p;
		wpc = c;
		cout << p.use_count() << endl;
		cout << c.use_count() << endl;
	}
	
	cout << wpp.use_count() << endl;
	cout << wpc.use_count() << endl;
}
```

上述代码中，parent有一个shared_ptr类型的成员指向孩子，而child也有一个shared_ptr类型的成员指向父亲。然后在创建孩子和父亲对象时也使用了智能指针c和p，随后将c和p分别赋给child的智能指针成员parent 和 prent的智能指针成员child。从而形成了一个循环引用。

### 8、内存泄漏如何解决

为了解决循环引用引起的内存泄漏，引入weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，类似于一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。

### 9、数组和指针的区别

| 指针                                                         | 数组                                 |
| :----------------------------------------------------------- | :----------------------------------- |
| 保存数据地址                                                 | 保存数据                             |
| 间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址获取数据 | 直接访问数据                         |
| 通常用于动态的数据结构                                       | 通常用于固定数目且数据类型相同的元素 |
| 通过malloc分配内存，free释放内存                             | 隐式的分配和删除                     |
| 通常指向匿名数据，操作匿名函数                               | 自身即为数据名                       |



### 10、野指针是什么

就是指向一个已经删除的对象或者未申请访问受限内存区域指针

### 11、C++中析构函数的作用

析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已经调用完毕，系统会自动执行析构函数。

析构函数名也应与类名相同，只是在函数名前面加一个位取反符～，例如 ~stud(), 以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）只能有一个析构函数，不能重载。

如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有显式的析构函数。

如果一个类中有指针，且使用的过程中动态申请了内存，那么最好显式构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。

### 12、为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数？

将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父亲类的时，设置为虚函数。

### 13、说一说虚函数和多态

多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候已经确定；动态多态使用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的虚函数，在父类中声明为加了 virtual 关键字的函数，在子类中重写时候不需要加virtual也是虚函数。

虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数放在代码段中。当子类继承父类的时候也会继承其虚函数表，当子类重写父类中的虚函数的时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存的开销，降低效率。

### 14、静态函数和虚函数的区别

静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销

### 15、说一下函数指针

**定义：**函数指针是只想函数的指针变量

函数指针本身首先是一个指针变量，该指针变量指向具体的函数。这正如用指针变量可指向整形变量、字符型、数组一样，这里指向函数

C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。

**用途：** 调用函数和做函数的参数，比如回调函数

**示例：**

```cpp
#include <bits/stdc++.h>
using namespace std;

int Max(int x, int y) {
	int z;
	if(x > y) z = x;
	else z = y;
	return z;
}

int main() {
	srand(time(NULL));
	int (*p) (int, int);
	int a, b, c;
	a = rand()%100; b = rand()%100;
	printf("a = %d b = %d\n", a, b);
	p = Max;
	c = (*p)(a, b);
	printf("max = %d\n", c);
}
```



### 16、说一下fork函数

fork：创建一个和当前进程映象一样的进程可以通过fork()系统调用

成功调用fork()会创建一个新的进程，它几乎与调用fork()的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork()调用会返回0。在父进程中fork()返回子进程的pid。如果出现错误，fork()返回的是一个负值

最常见的fork()用法是创建一个新的进程，然后使用exec()载入二进制映像，替换当前进程的映像。这种情况下，派生了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。

在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程页表项，然后把父进程的地址空间的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制的非常耗时的。现代Unix系统采取更多的优化，例如Linux，采用了**写时复制**的方法，而不是对父进程空间的进程整体复制



**写时复制**

在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈段都指向父进程的物理空间，也就是说，两者的虚拟空间不同，但是对应的物理空间时同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。

### 17、说一说重载与重写

**重载：** 两个函数名相同，但是参数列表不同（个数、类型），返回值类型没有要求，在同一作用域中

**重写：** 子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数。

### 18、说一说strlen和strcpy

**strcpy**是字符串拷贝函数，从src逐字节拷贝到dest，直到遇到 '\0' 结束，因为没有指定长度可能导致拷贝越界，造成缓冲区溢出漏洞，安全版本是strncpy函数

**strlen**函数是计算字符串长度的函数，返回从开始到'\0'之间的字符个数

### 19、说一下C++是怎么定义常量的？常量放在内存的哪个位置？

常量在C++里的定义就是const加上对象类型，常量定义必须初始化。

对于局部对象，常量存放在栈区；

对于全局对象，常量存放在 全局/静态存储区；

对于字面值常量，常量存放在常量存储区。

### 20、const修饰成员函数的目的是什么？

P41

### 21、如果定义了两个函数，一个带const，一个不带const，会有问题吗？

P41

### 22、说一下类型转换

P41

### 23、说一下隐式类型转换

P41

### 24、C++函数栈空间的最大值

P42

### 25、说一下 extern “C”

P42

### 26、请你回答一下 new/delete 与 malloc/free 的区别是什么

P42 P43

### 27、说一下RTTI

P42

### 28、说一下函数表具体是怎样实现运行时多态的？

P42

### 29、C语言是怎么进行函数调用的

P43

### 30、C语言参数压栈顺序

P43

### 31、C++如何处理返回值

P43

### 32、C++中拷贝赋值函数的形参能否进行值传递

P43

### 33、说一说select

P43

### 34、说一说fork、wait、exec 函数



## 容器和算法

### 请说一下map和set有什么区别，分别又是怎么实现的？

P45

### 介绍一下STL的allocator

P45

### 说一说STL迭代器删除元素

P46 P50

### STL中map数据存储方式

P46

### STL有什么基本组成

P46

### STL中的map与unordered_map

P47

### 说一说vector和list的区别

P47

### STL中迭代器的作用，有指针为什么还要迭代器

P49

### 说一说epoll原理

P49

### 回答一下STL里resize()和reverse()的区别

P51

## 类和数据抽象

### 请说一下C++中类成员的访问权限

P53

### C++中struct和class的区别

P54

### C++类内可以定义引用数据成员吗

P54

## 面向对象和泛型编程

### 请回答什么是右值引用，跟左值又有什么区别

P54

## 编译与底层

### 请说一下一个C++源文件从文本到可执行文件经历的过程

P55 P123

### 回答一下include头文件的顺序以及双引号 "" 和 尖括号 <> 的区别

P55

### 请回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么

P56

### C++的内存管理是怎样的

P56

### C++/C的内存分配

P57

### 如何判断内存泄漏

P58

### 什么时候会发生段错误

P58

### 什么是memory leak，也就是内存泄漏

P58

### C++如何处理内存泄漏

P62

### 回答一下new 和 malloc的区别

P59

### 说一下共享内存相关api

P60

### 说一下reactor模型组成

P61

### 设计一下如何采用单线程的方式处理高并发

P61

### 说一下select、epoll的区别，原理，性能，限制都说一说

P62

### 说一说STL的内存优化

P64

## C++11

### C++11有哪些新特性

P67

### 详细介绍一下C++11中的可变参数模版、右值引用和lambda这几个特性。

P68

